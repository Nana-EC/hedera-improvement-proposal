---
hip: 632
title: Hedera Account Service (HAS) System Contract
author: Nana Essilfie-Conduah <@nana-ec>, Luke Lee  <@lukelee-sl>
working-group: Danno Ferrin <@shemnon>, Richard Bair <@rbair23> , Ashe Oro <@ashe-oro>, Atul Mahamuni <@atul-hedera>
type: Standards Track
category: Service
needs-council-approval: Yes
status: Draft
created: 2022-11-28
discussions-to: https://github.com/hashgraph/hedera-improvement-proposal/discussions/638
updated: 2022-11-29
requires: 631
---

## Abstract

Virtual Addresses introduced a list of ECDSA public addresses that are stored in the account entity and serve as the account identifier on the EVM for transactions. This is in addition to the `Hedera address` that is used by default when no virtual addresses exist.

The result means accounts now have an organized presentation of different address formats that support historical formats and EVM equivlanet formats.
These addresses may be stored within smart contract state but without the ability to diferrentiate addresses.

## Motivation

Prior to HIP 631 smart contracts deployed may have stored an account Hedera address or the extracted public address from an ECDSA public key.
Additioally, when a virtual address is added to an account it will now present itself as the virutal address and no longer the Hedera address.
To avoid issues of lossed balance and permissions it is important that developers can distinguish between Hedera and virutal addresses.

Additionally, many smart contracts utilize `ECRECOVER` as part of their authorization process in smart contracts.
However, this is limited to `ECDSA` based signatures, which leaves `E25519` and complex key types not supported in Hedera.
To provide good user experience and to allow Hedera users to enjoy additioal feature benefits over EVM equivalanece it is important to provide authorization options within smart contract for non-ECDSA keys.

## Rationale

In smart contract exectutions the EVM will provide `msg.sender` values as either Hedera addresses or virtual addresses. 
To support authorization flows that check addresses either explicitly in smart contract code the network should support in smart contract distinguishing operations that allow smart contract to distinug between the two forms.
Additionally, to support standard implicit checks the network should support system contract checks in a manner similar `ECRECOVER` for easy developer support. 

## User stories

1. As a developer I want to be able to distinguish between Hedera addresses and virtual addresses within a smart contract so I can resolve address mappings in balance or permission scenarios.
2. As a developer I want to be able to confirm account authorization within a contract using simple `ECDSA`/`ED2519` key raw signatures as I would on Ethereum using `ECRECOVER`.
3. As a developer I want to be able to confirm account authorization for `ECDSA` accounts within a contract without being limited to `ECRECOVER`.
4. As a developer I want to be able to confirm account authorization for accounts within a contract using protobuf signature maps in a similar fashion as I would on Ethereum using `ECRECOVER`.
  
## Specification

A new system contract with functions to support address (Hedera and virtual) mapping reconciliation and authorization is proposed.

This will aid developers to support smart contract migration logic for cases where Hedera or virtual address values are encountered. Additionally, EVM developers who were limited to `ECRECOVER`  authorization flows will be able to expand authorization checks to other key types. 

| hash | signature | return | description |
| --- | --- | --- | --- |
|  | getVirtualAddresses(address) | address[] | returns an array of virtual addresses for an address  |
|  | getHederaAddress(address) | address | returns top level Hedera address if applicable |
|  | isVirtualAddress(address) | bool | true if valid evmAddress, false if long-zero or non existing account. |
|  | isAuthorized(address, messageHash, signatureBlob) | bool | true if account is authorized to carry out transaction execution on account. Accepts protobuf key signature blobs. May be used for ECDSA, ED25519 and complex key flows |
|  | isAuthorizedRaw(address, messageHash, signatureBlob) | bool | true if account is authorized to carry out transaction execution on account. Accepts single key raw signature blobs (ECDSA and ED25519). This provides similar logic to ECRECOVER. |

## Backwards Compatibility



## Security Implications

The ledger and the EVM maintain their authorization capabilities. In fact, it may be argued security is enhanced by the precompile support for contracts to verify both raw and protocol formatted signatures.

As always users and developers are responsible for key hygiene and proper storage of keys

## How to Teach This



## Reference Implementation



## Rejected Ideas



## Open Issues


## References

- [ECRECOVER Precompiled Contract](https://ethereum.github.io/execution-specs/autoapi/ethereum/frontier/vm/precompiled_contracts/ecrecover/index.html)
- [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf)

## Copyright/license

This document is licensed under the Apache License, Version 2.0 -- see [LICENSE](../LICENSE) or (https://www.apache.org/licenses/LICENSE-2.0)
